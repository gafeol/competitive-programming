#include <bits/stdc++.h>
using namespace std;
#define fst first
#define snd second
typedef unsigned long long ull;
typedef long long ll;
typedef pair<int, int> pii;
#define pb push_back
#define for_tests(t, tt) int t; scanf("%d", &t); for(int tt = 1; tt <= t; tt++)
#ifndef ONLINE_JUDGE
#define debug(args...) fprintf(stderr,args)
#else
#define debug(args...)
#endif //ONLINE_JUDGE
template<typename T> inline T abs(T t) { return t < 0? -t : t; }
const ll modn = 1000000007;
inline ll mod(ll x) { return x % modn; }

// vals ate 2**20 -1
const int MAXN = 1100006;

int n, m, k;
int s[MAXN];

vector<pii> adj[MAXN];

int mrk[MAXN];
int temp_path[MAXN], final_path[MAXN], tsz, fsz;

int usd[MAXN];
// Only use if graph is guaranteed to have an euler cycle
void euler_dfs(int u){
	temp_path[tsz++] = u;
    while(!adj[u].empty()){
        pii ar = adj[u].back();
        adj[u].pop_back();
		int id = ar.snd;
		if(mrk[id])
            continue;
		mrk[id] = 1;
		int v = ar.fst; 
        euler_dfs(v);
	}
	final_path[fsz++] = temp_path[--tsz];
}
// Cycle stored in final_path[0...fsz-1]

void add_edge(int u, int v, int id){
    adj[u].pb({v, id});
    adj[v].pb({u, id});
}

void print(int id, int u, int v, int k){
    if(u == (s[id*2]%(1<<k))){
        printf("%d %d ", id*2, id*2+1);
    }
    else
        printf("%d %d ", id*2+1, id*2);
}

int main (){
	scanf("%d", &n);
	for(int a=0;a<n;a++){
        int u, v;
        scanf("%d%d", &u, &v);
        s[a*2] = u;
        s[a*2+1] = v;
	}
    for(int k = 20;k>=0;k--){
        debug("k %d\n", k);
        for(int a=0;a<MAXN;a++){
        usd[a] = 0;
            adj[a].clear();
        }
        tsz = fsz = 0;
        map<int, map<int, vector<int>>> cord;
        for(int a=0;a<n;a++){
            int u = (s[a*2]%(1<<k));
            int v = (s[a*2+1]%(1<<k));
            add_edge(u, v, a);
            cord[u][v].pb(a);
            cord[v][u].pb(a);
        }
        int u = s[0]%(1<<k);
        euler_dfs(u);
        // checa se eh conexo?
        if(fsz == 2*n){
            printf("%d\n", k);
            for(int a=0;a<fsz;a++){
                int aa = (a + 1)%fsz;
                int u = final_path[a];
                int v = final_path[aa];
                int ar = cord[u][v].back();
                while(usd[ar]){
                    cord[u][v].pop_back();
                    ar = cord[u][v].back();
                }
                usd[ar] = 1;
                print(ar, u, v, k);
            }
        }
    }
}

